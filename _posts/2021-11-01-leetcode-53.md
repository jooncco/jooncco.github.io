---
title: "[LeetCode] 53. Maximum Subarray 풀이"
excerpt: "Data Structure I - Day 1"
header:
  overlay_image: /public/images/problem-solving-common-header.png
tags:
  - Array
  - Dynamic programming
  - Divide and conquer
last_modified_at: 2021-11-02T00:07:00+09:00
---
<a href="https://leetcode.com/">
    <img src="/public/images/leetcode-logo.jpeg"/>
</a>

## Problem
<a href="https://leetcode.com/problems/maximum-subarray/">
    <img src="/public/images/leetcode-53.png"/>
</a>

<br/>

## Key Idea
  
### 1) Brute force \\(O(n^3)\\)

### 2) Divide and conquer \\(O(n \log n)\\)

> \\([l,r]\\)에서 최대 부분배열은 아래 셋 중 하나다.

- \\(m = (l+r)/2\\)과 \\(m+1\\)번째 값을 포함하는 subarray  
- \\(m\\) 왼쪽 부분에서의 최대 부분배열  
- \\(m\\) 오른쪽 부분에서의 최대 부분배열

### 3) Kadane's algorithm (DP) \\(O(n)\\)
> 왼쪽부터 순회하면서, dp 배열을 아래 기준에 의해 업데이트하고, max 값을 동시에 update.

- \\(dp[i-1] + arr[i] \gt arr[i]\\) 이라면 \\(dp[i]= dp[i-1] + arr[i]\\)
- 아니라면 \\(dp[i]= arr[i]\\)

<br/>

## Solution
<img src="/public/images/leetcode-5-result.png"/>

```cpp
/**
 * author: jooncco
 * written: 2021. 11. 01. Mon. 23:03:16 [UTC+9]
 **/

typedef vector<int> vi;

class Solution {
private:
    int dnc(vi &arr, const int l, const int r) {
        if (l == r) return arr[l];
        int m= (l+r)/2;
        int lMax= -1e9-1;
        int sum= 0;
        for (int i=m; i >= l; --i) {
            sum += arr[i];
            lMax= max(lMax,sum);
        }
        int rMax= -1e9-1;
        sum= 0;
        for (int i=m+1; i <= r; ++i) {
            sum += arr[i];
            rMax= max(rMax,sum);
        }
        int single= max(dnc(arr, l, m), dnc(arr, m+1, r));
        return max(single, lMax+rMax);
    }
    
    int kadane(vi &arr) {
        int n= arr.size();
        int mx= -1e9-1;
        vi dp(n,-1e9-1);
        mx= dp[0]= arr[0];
        for (int i=1; i < n; ++i) {
            if (dp[i-1]+arr[i] > arr[i]) dp[i]= dp[i-1]+arr[i];
            else dp[i]= arr[i];
            mx= max(mx, dp[i]);
        }
        return mx;
    }
    
public:
    int maxSubArray(vi& nums) {
        return kadane(nums);
    }
};

```