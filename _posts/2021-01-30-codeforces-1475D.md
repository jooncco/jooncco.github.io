---
title: "[Codeforces] 1475D. Cleaning the Phone 풀이"
excerpt: "Codeforces Round #697(Div.3) - problem D solution"
header:
  overlay_image: /public/images/problem-solving-common-header.png
tags:
  - Two pointers
  - Sortings
  - Meet in the middle
last_modified_at: 2021-12-31T16:26:00+09:00
---
<a href="https://codeforces.com/">
    <img src="/public/images/codeforces-logo.jpeg"/>
</a>

## Problem
<a href="http://codeforces.com/problemset/problem/1475/D">
    <img src="/public/images/codeforces-1475D.png"/>
</a>

<br/>

## Key Idea

> 같은 convenience point를 포기한다면, 용량이 큰 것을 지우는게 이득이다.  

> CP가 1인 앱을 $$l$$개 지운다고 하면, 지워야할 2짜리 앱의 갯수 $$r$$도 정해진다.  

> convenience point( $$b_i$$ ) 별로 배열에 담아 sorting하고, $$l$$을 증가시키며 탐색.

<img src="/public/images/codeforces-1475D-figure-1.png"/>

각 $$l$$ 값에 따라 $$r$$ 값을 최대한 감소 시킨 후 convenience point를 계산.  
여기서 $$l$$ 은 증가, $$r$$ 은 감소할 일밖에 없기 때문에 linear time 안에 탐색이 가능해진다(Two pointers의 힘!).

$$ Time $$ $$ Complexity: O(n) $$

<br/>

## Solution
<img src="/public/images/codeforces-1475D-result.png"/>

```cpp
/**
 * author: jooncco
 * written: 2021. 1. 30. Sat. 00:16:12 [UTC+9]
 **/

#include <bits/stdc++.h>
using namespace std;
using ll= long long;
using ii= pair<int,int>;
using vi= vector<int>;
using di= deque<int>;

const int INF= 1000000007;
int t,n,m;

int main() {

    cin >> t;
    while (t--) {
        cin >> n >> m;
        vi one,two;
        vi arr(n);
        for (int &e : arr) cin >> e;
        int b;
        for (int i=0; i < n; ++i) {
            cin >> b;
            if (b == 1) one.push_back(arr[i]);
            if (b == 2) two.push_back(arr[i]);
        }
        sort(one.rbegin(),one.rend());
        sort(two.rbegin(),two.rend());
        ll sum1= 0, sum2= accumulate(two.begin(),two.end(),0ll);
        ll ans= INF;
        int r= two.size();
        for (int l=0; l <= one.size(); ++l) {
            while (r > 0 && sum1 + sum2 - two[r-1] >= m) {
                sum2 -= two[r-1];
                --r;
            }
            if (sum1 + sum2 >= m) {
                ans= min(ans,l+2ll*r);
            }
            if (l < one.size()) {
                sum1 += one[l];
            }
        }
        cout << (ans == INF ? -1 : ans) << "\n";
    }
}

```