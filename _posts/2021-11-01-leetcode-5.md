---
title: "[LeetCode] 5. Longest Palindromic Substring 풀이"
excerpt: "dp 연습용"
header:
  overlay_image: /public/images/problem-solving-common-header.png
tags:
  - String
  - Dynamic programming
last_modified_at: 2021-11-01T23:54:00+09:00
---
<a href="https://leetcode.com/">
    <img src="/public/images/leetcode-logo.jpeg"/>
</a>

## Problem
<a href="https://leetcode.com/problems/longest-palindromic-substring/">
    <img src="/public/images/leetcode-5.png"/>
</a>

<br/>

## Key Idea
- 내가 이미 알고있는 최대 길이가 \\(l\\) 이라면, 길이가 \\(l\\) 이하인 Palindrome은 찾을 필요가 없음.
- 첫 문자부터 순회하면서, 왼쪽 방향으로 현재까지 최대 길이인 \\(l\\)만큼 문자를 보고, 이 문자가 추가되어서 길이가 \\(l+1\\) 혹은 \\(l+2\\)가 될 수 있는지만 체크.

$$ Time $$ $$ Complexity: O(|s|) $$


<br/>

## Solution
<img src="/public/images/leetcode-5-result.png"/>

```cpp
/**
 * author: jooncco
 * written: 2021. 10. 31. Mon. 00:30:16 [UTC+9]
 **/

#include <vector>
typedef vector<int> vi;

class Solution {
private:
    bool isPalindrome(string str) {
        int n= str.length();
        for (int i=0; i < n/2; ++i) {
            if (str[i] != str[n-1-i]) return 0;
        }
        return 1;
    }
    
public:
    string longestPalindrome(string s) {
        int n= s.length();
        int idx= 0, len= 0;
        for (int i=0; i < n; ++i) {
            if (isPalindrome(s.substr(i-len, len+1))) {
                idx= i-len;
                len += 1;
            }
            else if (i-len > 0 && isPalindrome(s.substr(i-len-1, len+2))) {
                idx= i-len-1;
                len += 2;
            }
        }
        return s.substr(idx,len);
    }
};

```